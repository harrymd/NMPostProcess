'''
NMPostProcess/common.py
Various scripts used by multiple functions.
'''

# Import standard modules.
from glob import glob
import os

# Import third-party modules.
import numpy as np

# Generic operations. ---------------------------------------------------------
def mkdir_if_not_exist(dir_):
    '''
    Creates a directory if it does not exist.

    Input

    dir_    The path of the directory to be created.

    Output

            None
    '''

    if not os.path.exists(dir_):
        
        print('Creating directory {:}'.format(dir_))
        os.mkdir(dir_)

    else:

        print('Directory {:} exists. Skipping directory creation.'.format(dir_))

    return

# Read files.
def read_eigenvalues(file_eigval_list):
    '''
    Reads the eigenvalue list file generated by process.write_eigenvalues().

    Input

    file_eigval_list    The eigenvalue file.

    Output

    i_mode              A list of mode IDs (1, 2, ..., n_mode).
    freq                A list of frequencies.
    '''
    
    data    = np.loadtxt(file_eigval_list)
    num     = data[:, 0].astype(np.int)
    freq    = data[:, 1]
    
    return num, freq

def get_list_of_modes_from_output_files(dir_NM):
    '''
    Searches output directory for matching filenames and returns a list of mode IDs.

    Input:

    dir_NM
        See 'Definition of variables' in NMPostProcess/process.py.

    Output:

    i_mode_list
        A list of mode ID integers.
    '''

    regex_eigvec = '*.dat'
    path_regex_eigvec = os.path.join(dir_NM, regex_eigvec)
    eigvec_path_list = glob(path_regex_eigvec)
    #
    i_mode_list = []
    for eigvec_path in eigvec_path_list:

        # Remove .dat suffix.
        eigvec_path = eigvec_path[:-4]

        # Get integer at end of file name.
        try:

            i_mode = int(eigvec_path.split('_')[-1])
        
            # Save.
            i_mode_list.append(i_mode)

        # Ignore other files e.g. *_vlist.dat which do not end with integers. 
        except ValueError:

            pass

    # Convert to NumPy array and sort.
    i_mode_list = np.array(i_mode_list, dtype = np.int)
    i_mode_list = np.sort(i_mode_list)

    return i_mode_list

def load_vsh_coefficients(dir_NM, i_mode):
    '''
    Loads the vector spherical harmonic coefficients created by NMPostProcess/process.py.

    Input:

    dir_NM, i_mode
        See 'Definitions of variables'.

    Output:

    Ulm, Vlm, Wlm, scale, r_max, i_region_max
        See 'Definition of variables' in NMPostProcess/process.py.
    '''

    # Create the file path and load the NumPy array.
    dir_processed = os.path.join(dir_NM, 'processed')
    dir_spectral = os.path.join(dir_processed, 'spectral')
    file_spectral_data = 'quick_spectral_{:>05d}.npy'.format(i_mode)
    path_spectral_data = os.path.join(dir_spectral, file_spectral_data)
    spectral_data = np.load(path_spectral_data)

    # Read the first header line to get the radius information.
    header_radius       = np.real(spectral_data[:, 0])
    r_max               = header_radius[0]
    i_region_max        = int(header_radius[1])

    # Read the second header line to get the scale information.
    header_scale = np.real(spectral_data[:, 1])
    scale = header_scale[0]

    # Read the coefficients.
    Ulm, Vlm, Wlm = spectral_data[:, 2:]

    return Ulm, Vlm, Wlm, scale, r_max, i_region_max

# Functions related to spherical harmonics.
def convert_complex_sh_to_real(Xlm, l_max):
    '''
    Converts complex spherical harmonics to real ones.
    Dahlen and Tromp (1998), eq. B.98.

    Input:

    Xlm
        The complex spherical harmonic coefficients in SHTns format. The number of coefficients is (l_max + 1)(l_max + 2)/2.
    l_max
        The maximum angular order which was used in SHTns to calculate the coefficients.
    
    Returns:

    xlm
        The real spherical harmonic coefficients. The number of coefficients is (l_max + 1)*(l_max + 1).
    l_real
        A list of the l-values corresponding to each coefficient.
    m_real
        A list of the m-values corresponding to each coefficient.
    '''
    
    # Initialise output arrays.
    sqrt2 = np.sqrt(2.0)
    n_coeff = (l_max + 1)**2
    xlm     = np.zeros(n_coeff)
    l_real  = np.zeros(n_coeff, dtype = np.int)
    m_real  = np.zeros(n_coeff, dtype = np.int) 
    
    i_complex = 0
    i_real = 0
    for m_complex in range(l_max + 1):

        for l_complex in range(m_complex, l_max + 1):
            
            coeff_complex = Xlm[i_complex]
            
            if m_complex == 0:
                
                assert np.imag(coeff_complex) == 0.0
                
                i_real_0 = l_complex*(l_complex + 1)

                xlm[i_real_0] = np.real(coeff_complex)

                m_real[i_real_0] = 0
                l_real[i_real_0] = l_complex

            else:
                
                i_real_pos = (l_complex*(l_complex + 1)) + m_complex
                i_real_neg = (l_complex*(l_complex + 1)) - m_complex

                xlm[i_real_pos] =  sqrt2*np.real(coeff_complex)
                xlm[i_real_neg] = -sqrt2*np.imag(coeff_complex)

                m_real[i_real_pos] =  m_complex
                m_real[i_real_neg] = -m_complex

                l_real[i_real_pos] = l_complex
                l_real[i_real_neg] = l_complex

            i_complex = i_complex + 1

    return xlm, l_real, m_real

def make_l_and_m_lists(l_max):
    '''
    Calculates the lists of the angular and azimuthal order of coefficients stored in SHTns format.

    Input:

    l_max
        The maximum l-value used for calculation the coefficients with SHTns.

    Output:

    l_list, m_list
        The l- and m-values corresponding to each coefficient.
    '''

    n = (l_max + 1)*(l_max + 2)//2
    
    l_list = np.zeros(n, dtype = np.int)
    m_list = np.zeros(n, dtype = np.int)

    k = 0
    for i in range(l_max + 1):
        
        for j in range(i, l_max + 1):
            
            l_list[k] = j
            m_list[k] = i

            k = k + 1

    return l_list, m_list

# Miscellaneous functions. ----------------------------------------------------
def lf_clusters(l, f, f_tol = 0.001):
    '''
    Groups modes with the same l-value and similar frequencies into clusters.
    
    Variables

    (n_modes)   The number of modes.

    Input

    l       (n_modes) A list of the l-value of each mode.
    f       (n_modes) A list of the frequency of each mode.
    f_tol   The maximum frequency gap within a cluster.

    Output

    i_clusters      (n_clusters) For each cluster, a list (of length cluster_multipliticies[i]) of the indices of the modes of the cluster within the original list.
    l_clusters      (n_clusters) For each cluster, the l-value of that cluster.
    f_clusters      (n_clusters) For each cluster, a list (of length cluster_multiplicities[i]) of the frequencies of the modes of the cluster. 
    n_clusters      The number of clusters found.
    f_cluster_means (n_clusters) The mean frequency of each cluster.
    cluster_multiplicities
                    (n_cluster) The number of modes in each cluster.
    '''

    # Initialise output arrays.
    l_clusters = []
    f_clusters = []
    i_clusters = []

    # Initialise loop variables.
    # i_remain  A list of indices of modes which have not yet been assigned a cluster.
    # n_remain  The number of modes which have not been assigned a cluster.
    n_modes = len(l)
    i_remain = list(range(0, n_modes))
    n_remain = len(i_remain)

    # Assign each mode a cluster.
    while n_remain > 0:
        
        # Start a new cluster.
        l_cluster = l[i_remain[0]]
        #
        i_cluster = [i_remain[0]]
        f_cluster = [f[i_remain[0]]]
        #
        del i_remain[0]
        n_remain = len(i_remain)
        
        j = 0
        while j < n_remain:
            
            i = i_remain[j]

            # Find the bounds of the current cluster.
            f_min = np.min(f_cluster)
            f_max = np.max(f_cluster)
            
            # Add modes with matching l-values, but only if they
            # are close (in frequency) to the current cluster.
            if l[i] == l_cluster:
                
                # Check if the mode frequency is close enough to the
                # current cluster.
                if (f[i] > (f_min - f_tol)) and (f[i] < (f_max + f_tol)):

                    # Add the mode to the cluster.
                    i_cluster.append(i)
                    f_cluster.append(f[i])

                    del i_remain[j]
                    n_remain = len(i_remain)
                    
                    # Restart the search for this value, as the
                    # cluster has a new entry and its bounding 
                    # frequencies may have changed.
                    j = 0
                    continue

            j = j + 1
    
        # Once all the l-values have been checked, the cluster is complete.
        # Store the cluster and its frequencies in the master list.
        l_clusters.append(l_cluster)
        f_clusters.append(np.array(f_cluster))
        i_clusters.append(np.array(i_cluster, dtype = np.int))

    # Find how many clusters there are.
    n_clusters = len(l_clusters)

    # Find the mean frequency of each cluster.
    f_cluster_means = np.zeros(n_clusters)
    for i in range(n_clusters):

        f_cluster_means[i] = np.mean(f_clusters[i])
    
    # Find the number of modes in each cluster.
    cluster_multiplicities = np.zeros(n_clusters, dtype = np.int32)
    for i in range(n_clusters):

        cluster_multiplicities[i] = len(f_clusters[i])

    return i_clusters, l_clusters, f_clusters, n_clusters, f_cluster_means, cluster_multiplicities
